{-# LANGUAGE ApplicativeDo #-}

module ScriptExample where

import Daml.Script
import DA.Assert
import DA.List
import DA.Foldable (mapA_)

type DirectoryId = ContractId Directory
type FileId = ContractId File

template File with
    creator: Party
    owner: Party
    name: Text
    content: Text
    path: DirectoryId
  where
    signatory creator
    observer owner

    nonconsuming choice DeleteFile: () with
      controller owner
      do
        archive self

    choice ChangeFileOwner: FileId with
        newPath: DirectoryId
        newOwner: Party
      controller owner
      do
        create this with path = newPath, owner = newOwner


template Directory with
    creator: Party
    parent: Optional (DirectoryId)
    name: Text
    owner: Party
    directories: [DirectoryId]
    files: [FileId]
  where
    signatory creator
    observer owner

    -- TODO: not sure if required (see usage below)
    -- nonconsuming choice AddDirectory: DirectoryId with
    --     directory: DirectoryId
    --   controller owner
    --   do
    --     archive self
    --     dirNew <- create this with directories = directories ++ [directory]
    --     case parent of
    --       None -> return dirNew
    --       Some p -> exercise p AddDirectory with directory = dirNew

    nonconsuming choice CreateDirectory: DirectoryId with
        dirName: Text
      controller owner
      do
        existing <- mapA fetch directories
        assertMsg "Directory already exists" $ dirName `notElem` (map (\e -> e.name) existing)

        subDir <- create Directory with creator = creator, parent = Some self, owner = owner, name = dirName, directories = [], files = []
        archive self
        create this with directories = directories ++ [subDir]
        
        -- TODO: not sure if its necessary to propagate up the folder tree
        -- dirNew <- create this with directories = directories ++ [subDir]
        -- case parent of
        --   None -> return dirNew
        --   Some p -> exercise p AddDirectory with directory = dirNew

    nonconsuming choice DeleteDirectory: () with
      controller owner
      do
        mapA_ (`exercise` DeleteDirectory) directories
        mapA_ (`exercise` DeleteFile) files
        archive self

    nonconsuming choice ChangeDirectoryOwner: DirectoryId with
        newParent: Optional (DirectoryId)
        newOwner: Party
      controller owner
      do
        assertMsg "Already belongs to this person" $ owner /= newOwner
        archive self
        new <- create this with owner = newOwner, parent = None
        mapA_ (\d -> exercise d ChangeDirectoryOwner with newParent = Some new, newOwner = owner) directories
        mapA_ (\f -> exercise f ChangeFileOwner with newPath = new, newOwner = owner) files
        return new

    nonconsuming choice CreateFile: FileId with
        fileName: Text
        content: Text
      controller owner
      do
        existing <- mapA fetch files
        assertMsg "File already exists" $ fileName `notElem` (map (\e -> e.name) existing)
        file <- create File with creator = creator, owner = owner, name = fileName, content = content, path = self
        archive self
        create this with files = files ++ [file]
        return file

-- Test Setup

data LedgerParties = LedgerParties with
  alice : Party
  bob : Party

allocateParties : Script LedgerParties
allocateParties = do
  alice <- allocateParty "alice"
  bob <- allocateParty "bob"
  pure (LedgerParties alice bob)

initialize : LedgerParties -> Script ()
initialize parties = do
  dirAlice <- submit parties.alice $ createCmd (Directory parties.alice None "/alice" parties.alice [] [])
  dirBob <- submit parties.bob $ createCmd (Directory parties.bob None "/bob" parties.bob [] [])
  pure ()

-- Run tests

test : Script ()
test = do
  parties@LedgerParties{..} <- allocateParties
  initialize parties

  -- Create root directories for Alice and Bob
  aliceDirs <- query @Directory alice
  assertEq [
    Directory parties.alice None "/alice" parties.alice [] []
    ] (map snd aliceDirs)

  bobDirs <- query @Directory bob
  assertEq [
    Directory parties.bob None "/bob" parties.bob [] []
    ] (map snd bobDirs)

  -- Alice creates a file in /alice
  let aliceRootDir = head $ map fst aliceDirs
  submit alice $ exerciseCmd aliceRootDir (CreateFile "File1" "my name is Alice")
  
  aliceFiles <- query @File alice
  assertEq [
      File parties.alice parties.alice "File1" "my name is Alice" aliceRootDir
    ] (map snd aliceFiles)

  -- Alice cannot create file with same name
  submitMustFail alice $ exerciseCmd aliceRootDir (CreateFile "File1" "")

  -- Bob is not allowed to create a file in /alice
  submitMustFail bob $ exerciseCmd aliceRootDir (CreateFile "File2" "my name is Bob")

  -- Alice/Bob removes files
  aliceFiles <- query @File alice
  let aliceFileIds = map fst aliceFiles
  mapA_ (\f -> submitMustFail bob $ exerciseCmd f DeleteFile) aliceFileIds
  mapA_ (\f -> submit alice $ exerciseCmd f DeleteFile) aliceFileIds
  aliceFiles <- query @File alice
  assertEq [] (map snd aliceFiles)

  -- Alice creates directory and file and subsequently removes directory
  rootDir <- submit parties.alice $ createCmd (Directory parties.alice None "/alice" parties.alice [] [])
  fileInRootDir <- submit alice $ exerciseCmd rootDir (CreateFile "File1" "I will be removed soon")
  submit alice $ exerciseCmd fileInRootDir DeleteFile
  -- TODO: how to archive contract with dependency?
  -- submit alice $ exerciseCmd rootDir (DeleteDirectory alice)
  -- aliceDirs <- query @Directory alice
  -- assertEq [] (map snd aliceDirs)
  pure ()
